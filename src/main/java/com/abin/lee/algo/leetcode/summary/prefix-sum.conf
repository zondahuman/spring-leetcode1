
前缀和技巧：
回顾一下，前缀和数组 preSum 就是 nums 元素的累加和，preSum[i+1] - preSum[j] 其实就是子数组 nums[j..i] 之和（根据 preSum 数组的实现，索引 0 是占位符，所以 i 有一位索引偏移）。
那么反过来想，以 nums[i] 为结尾的最大子数组之和是多少？其实就是 preSum[i+1] - min(preSum[0..i])。


https://labuladong.online/algo/data-structure/prefix-sum/
前缀和技巧有几个局限性。

第一个局限性：使用前缀和技巧的前提是原数组 nums 不会发生变化。
第二个局限性：前缀和技巧只适用于存在逆运算的场景。
比方说求和的场景，你知道 x+6=10x+6=10，那么可以推导出 x=10−6=4x=10−6=4，求乘积的场景也是类似的，
你知道 x∗6=12x∗6=12，那么可以推导出 x=12/6=2x=12/6=2，这就叫存在逆运算，都可以使用前缀和技巧。
但有些场景是没有逆运算的，比方说求最大值的场景，你知道 max(x,8)=8max(x,8)=8，此时你无法推导出 xx 的值。
想要同时解决这两个问题，就需要更高级的数据结构，最通用的解决方案是 线段树，我们会在数据结构设计章节具体讲解。


这个技巧在生活中运用也挺广泛的，比方说，你们班上有若干同学，每个同学有一个期末考试的成绩（满分 100 分），那么请你实现一个 API，输入任意一个分数段，返回有多少同学的成绩在这个分数段内。
那么，你可以先通过计数排序的方式计算每个分数具体有多少个同学，然后利用前缀和技巧来实现分数段查询的 API：

前缀和框架：
// 存储着所有同学的分数
int[] scores = new int[]{...};
// 试卷满分 100 分
int[] count = new int[100 + 1];

// 记录每个分数有几个同学
for (int score : scores) {
    count[score]++;
}
// 构造前缀和数组
for (int i = 1; i < count.length; i++) {
    count[i] = count[i] + count[i-1];
}

// 利用 count 这个前缀和数组进行分数段查询

// 查询分数在 [80, 90] 之间的同学有多少人
int result = count[90] - count[80];

